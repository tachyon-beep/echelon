<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Echelon Replay Viewer</title>
    <style>
        body { margin: 0; overflow: hidden; background: #111; color: #eee; font-family: sans-serif; }
        #ui { position: absolute; top: 10px; left: 10px; z-index: 100; background: rgba(0,0,0,0.8); padding: 10px; border-radius: 5px; }
        #controls { margin-top: 10px; }
        input[type="range"] { width: 300px; }
        button { cursor: pointer; padding: 5px 10px; background: #333; color: #fff; border: 1px solid #555; }
        button:hover { background: #444; }
        #stats { margin-top: 5px; font-size: 0.9em; color: #aaa; }
    </style>
    <!-- Import Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="ui">
        <h3>Echelon Replay Viewer</h3>
        <div style="margin-bottom: 10px;">
            <strong>Local:</strong> <input type="file" id="fileInput" accept=".json">
        </div>
        <div style="margin-bottom: 10px;">
            <strong>Server:</strong>
            <select id="serverFileList">
                <option value="">-- Select a Replay --</option>
            </select>
            <button id="refreshBtn">â†»</button>
            <button id="loadServerBtn">Load</button>
        </div>
        <div id="controls" style="display:none;">
            <button id="playPause">Play</button>
            <input type="range" id="timeSlider" min="0" max="100" step="0.1" value="0">
            <span id="timeDisplay">0.0s</span>
            <button id="navToggle">Nav</button>
            <button id="pathToggle">Path</button>
            <div id="stats"></div>
        </div>
        <div id="infoPanel" style="margin-top: 10px; border-top: 1px solid #555; padding-top: 5px; font-size: 0.9em; display: none;">
            <strong>SELECTED:</strong> <span id="selId">None</span><br>
            Class: <span id="selClass">-</span><br>
            HP: <span id="selHp">-</span> / <span id="selMaxHp">-</span><br>
            Heat: <span id="selHeat">-</span> / <span id="selHeatCap">-</span><br>
            Stab: <span id="selStab">-</span> / <span id="selStabMax">-</span><br>
            Legged: <span id="selLegged">-</span><br>
            Suppressed: <span id="selSuppressed">-</span><br>
            EWAR: <span id="selEwar">-</span><br>
            AMS CD: <span id="selAms">-</span><br>
            State: <span id="selState">-</span>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let replayData = null;
        let isPlaying = false;
        let currentTime = 0;
        let maxTime = 0;
        let playbackSpeed = 1.0;
        let lastFrameTime = 0;

        // Objects
        let mechMeshes = {}; // {id: mesh}
        let wallMesh = null;
        let captureZoneMesh = null;
        let laserLines = [];
        let missileMeshes = [];
        let paintHelpers = {}; // {id: wireframeBox}
        let statusBars = {}; // {id: {hp: mesh, stab: mesh, heat: mesh, group: Object3D}}
        let floaters = []; // [{mesh, vel, life}]
        let navGroup = new THREE.Group();
        let pathGroup = new THREE.Group();
        let ewarMeshes = {}; // {id: mesh}

        // Config
        const VOXEL_SIZE = 1.0; // Visual scale
	        const TEAM_COLORS = { "blue": 0x3388ff, "red": 0xff3333 };
	        const MECH_SIZES = {
	            "scout": [0.5, 0.5, 0.9],
	            "light": [0.6, 0.6, 1.0],
	            "medium": [1.0, 1.0, 1.0],
	            "heavy": [1.5, 1.5, 2.0]
	        };
	        // Sim mech positions are AABB centers; these are the sim half-heights so models sit on z=0.
	        const MECH_HALF_HEIGHTS = { "scout": 0.9, "light": 1.0, "medium": 1.5, "heavy": 2.0 };

        let selectedMechId = null;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            scene.fog = new THREE.Fog(0x1a1a1a, 20, 100);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(-10, -10, 20);
            camera.up.set(0, 0, 1); // Z-up

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Lights
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            hemiLight.position.set(0, 0, 50);
            scene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
            dirLight.position.set(50, 50, 100);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // Grid - Initial placeholder, will resize on load
            const gridHelper = new THREE.GridHelper(40, 40, 0x444444, 0x222222);
            gridHelper.rotation.x = Math.PI / 2;
            gridHelper.position.set(20, 20, 0); // Center placeholder
            scene.add(gridHelper);
            window.gridHelper = gridHelper;

            scene.add(navGroup);
            scene.add(pathGroup);

            // WebSocket connection
            connectWebSocket();

            // Initial fetch of server files
            fetchFileList();

            // UI Listeners
            document.getElementById('fileInput').addEventListener('change', handleFileSelect, false);
            document.getElementById('refreshBtn').addEventListener('click', fetchFileList);
            document.getElementById('loadServerBtn').addEventListener('click', loadServerReplay);

            document.getElementById('playPause').addEventListener('click', togglePlay);
            document.getElementById('navToggle').addEventListener('click', toggleNav);
            document.getElementById('pathToggle').addEventListener('click', togglePath);
            document.getElementById('timeSlider').addEventListener('input', (e) => {
                currentTime = parseFloat(e.target.value);
                updateScene(currentTime);
                isPlaying = false;
                document.getElementById('playPause').innerText = "Play";
            });
            window.addEventListener('resize', onWindowResize);

            // Add click listener
            renderer.domElement.addEventListener('pointerdown', onPointerDown, false);
        }
        
        function onPointerDown(event) {
            // Calculate mouse position
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            // Check intersection with mech meshes
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            // Find first parent that is a mech group
            let found = null;
            for (let hit of intersects) {
                // Traverse up to find the group in mechMeshes
                let obj = hit.object;
                while (obj) {
                    // Check if obj is one of our mech groups
                    for (const [mid, mesh] of Object.entries(mechMeshes)) {
                        if (mesh === obj) {
                            found = mid;
                            break;
                        }
                    }
                    if (found) break;
                    obj = obj.parent;
                }
                if (found) break;
            }
            
            selectedMechId = found;
            const panel = document.getElementById('infoPanel');
            panel.style.display = found ? 'block' : 'none';
            
            // Auto-refresh path if visible
            if (pathGroup.visible && found) {
                requestPath(found);
            }
        }

        function fetchFileList() {
            fetch('/replays')
                .then(response => response.json())
                .then(files => {
                    const sel = document.getElementById('serverFileList');
                    sel.innerHTML = '<option value="">-- Select a Replay --</option>';
                    files.forEach(f => {
                        const opt = document.createElement('option');
                        opt.value = f.path;
                        opt.innerText = f.name;
                        sel.appendChild(opt);
                    });
                })
                .catch(err => console.error("Failed to fetch replays:", err));
        }

        function loadServerReplay() {
            const path = document.getElementById('serverFileList').value;
            if (!path) return;
            
            fetch('/replays/' + path)
                .then(response => response.json())
                .then(data => {
                    console.log("Loaded server replay:", path);
                    replayData = data;
                    setupReplay();
                })
                .catch(err => alert("Error loading replay: " + err));
        }

        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const ws = new WebSocket(`${protocol}//${window.location.host}/ws`);
            
            ws.onmessage = (event) => {
                const msg = JSON.parse(event.data);
                if (msg.type === 'replay') {
                    console.log("Received new replay via WebSocket");
                    replayData = msg.data;
                    setupReplay();
                    // Auto play new arrivals?
                    isPlaying = true;
                    document.getElementById('playPause').innerText = "Pause";
                }
            };

            ws.onclose = () => {
                console.log("WebSocket closed. Retrying in 5s...");
                setTimeout(connectWebSocket, 5000);
            };
        }

        function handleFileSelect(evt) {
            const file = evt.target.files[0];
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    replayData = JSON.parse(e.target.result);
                    setupReplay();
                } catch (err) {
                    alert("Error parsing JSON: " + err);
                }
            };
            reader.readAsText(file);
        }

	        function setupReplay() {
	            if (!replayData || !replayData.frames || replayData.frames.length === 0) return;

	            // Clean up old scene
	            if (window.worldMeshes) {
                    window.worldMeshes.forEach(m => scene.remove(m));
                    window.worldMeshes = [];
                }
	            if (captureZoneMesh) scene.remove(captureZoneMesh);
	            Object.values(mechMeshes).forEach(m => scene.remove(m));
	            mechMeshes = {};
	            Object.values(statusBars).forEach(sb => scene.remove(sb.group));
	            statusBars = {};
	            laserLines.forEach(l => scene.remove(l));
	            laserLines = [];
	            missileMeshes.forEach(m => scene.remove(m));
	            missileMeshes = [];
	            Object.values(paintHelpers).forEach(h => scene.remove(h));
	            paintHelpers = {};
	            floaters.forEach(f => scene.remove(f.mesh));
	            floaters = [];
                Object.values(ewarMeshes).forEach(m => scene.remove(m));
                ewarMeshes = {};
                navGroup.clear();
                pathGroup.clear();

	            // Parse World
	            if (replayData.world) {
                // Resize Grid
                if (window.gridHelper) scene.remove(window.gridHelper);
                const wx = replayData.world.size[0];
                const wy = replayData.world.size[1];
                const maxDim = Math.max(wx, wy);
                
                window.gridHelper = new THREE.GridHelper(maxDim, maxDim, 0x444444, 0x222222);
                window.gridHelper.rotation.x = Math.PI / 2;
                window.gridHelper.position.set(wx/2, wy/2, 0);
                scene.add(window.gridHelper);

                // Re-center camera if first load
                const meta = replayData.world.meta || {};
                const cz = meta.capture_zone || null;
                let czX = wx / 2;
                let czY = wy / 2;
                let czR = 15.0;
                if (cz) {
                    if (Array.isArray(cz.center) && cz.center.length >= 2) {
                        czX = cz.center[0];
                        czY = cz.center[1];
                    }
                    if (typeof cz.radius === 'number') {
                        czR = cz.radius;
                    }
                }
                controls.target.set(czX, czY, 0);

                // Draw Capture Zone
                const inner = Math.max(0.1, czR - 0.5);
                const outer = Math.max(inner + 0.1, czR + 0.5);
                const ringGeo = new THREE.RingGeometry(inner, outer, 48);
                const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, side: THREE.DoubleSide, transparent: true, opacity: 0.5 });
                captureZoneMesh = new THREE.Mesh(ringGeo, ringMat);
                captureZoneMesh.position.set(czX, czY, 0.1);
                scene.add(captureZoneMesh);

                if (replayData.world.walls) {
                    const solidGeometry = new THREE.BoxGeometry(VOXEL_SIZE, VOXEL_SIZE, VOXEL_SIZE);
                    const tileHeight = VOXEL_SIZE * 0.12;
                    const tileGeometry = new THREE.BoxGeometry(VOXEL_SIZE, VOXEL_SIZE, tileHeight);
                    // We'll use multiple instanced meshes for different types if needed,
                    // or just a single one with colors. InstancedMesh supports colors!
                    
                    const materials = {
                        1: new THREE.MeshLambertMaterial({ color: 0x555555 }), // SOLID
                        2: new THREE.MeshLambertMaterial({ color: 0xff4400, emissive: 0x441100 }), // LAVA
                        3: new THREE.MeshLambertMaterial({ color: 0x0044ff, transparent: true, opacity: 0.8 }), // WATER
                        4: new THREE.MeshLambertMaterial({ color: 0x555555, emissive: 0xff2200, transparent: true, opacity: 0.7 }), // HOT_DEBRIS
                        5: new THREE.MeshLambertMaterial({ color: 0x333333, roughness: 0.8 }), // KILLED_HULL
                        6: new THREE.MeshLambertMaterial({ color: 0x6b4f2a, roughness: 1.0 }) // DIRT
                    };
                    
                    // Group walls by type for efficient instancing
                    const byType = {};
                    replayData.world.walls.forEach(w => {
                        // w is [x, y, z, type] or just [x, y, z] (legacy)
                        const type = w[3] || 1;
                        if (!byType[type]) byType[type] = [];
                        byType[type].push(w);
                    });
                    
                    Object.entries(byType).forEach(([type, walls]) => {
                        const typeNum = Number(type);
                        const isTile = (typeNum === 2 || typeNum === 3 || typeNum === 6);
                        const geom = isTile ? tileGeometry : solidGeometry;
                        const iMesh = new THREE.InstancedMesh(geom, materials[type] || materials[1], walls.length);
                        const matrix = new THREE.Matrix4();
                        walls.forEach((w, i) => {
                            const x = w[0] + 0.5;
                            const y = w[1] + 0.5;
                            const z = w[2];
                            let zCenter = z + 0.5;
                            if (typeNum === 6) {
                                // Dirt is a thin "floor" tile sitting just below z=0.
                                zCenter = z - (tileHeight * 0.5) - 0.001;
                            } else if (typeNum === 2 || typeNum === 3) {
                                // Water/lava are thin surface patches on top of the ground.
                                zCenter = z + (tileHeight * 0.5) + 0.001;
                            }
                            matrix.setPosition(x, y, zCenter);
                            iMesh.setMatrixAt(i, matrix);
                        });
                        iMesh.instanceMatrix.needsUpdate = true;
                        iMesh.frustumCulled = false;
                        scene.add(iMesh);
                        // Store for cleanup
                        if (!window.worldMeshes) window.worldMeshes = [];
                        window.worldMeshes.push(iMesh);
                    });
                }
            }

            // Metadata / stats
            const meta = (replayData.world && replayData.world.meta) ? replayData.world.meta : {};
            const seed = (replayData.world && replayData.world.seed !== undefined) ? replayData.world.seed : "n/a";
            const archetype = meta.archetype_name || meta.archetype || "n/a";
            const diag = (meta.highway_diagonal !== undefined) ? meta.highway_diagonal : null;
            const transform = meta.transform || (meta.recipe && meta.recipe.variant && meta.recipe.variant.transform) || "n/a";
            const spawns = meta.spawn_corners ? `${meta.spawn_corners.blue}/${meta.spawn_corners.red}` : "n/a";
            const size = (replayData.world && replayData.world.size) ? replayData.world.size : null;
            const sizeStr = size ? `${size[0]}x${size[1]}x${size[2]}` : "n/a";
            const wallCount = (replayData.world && replayData.world.walls) ? replayData.world.walls.length : 0;
            const czInfo = (meta.capture_zone && Array.isArray(meta.capture_zone.center) && typeof meta.capture_zone.radius === 'number')
                ? ` zone=(${meta.capture_zone.center[0].toFixed(1)},${meta.capture_zone.center[1].toFixed(1)}) r=${meta.capture_zone.radius.toFixed(1)}`
                : '';
            document.getElementById('stats').innerText = `seed=${seed} archetype=${archetype}${diag !== null ? ` diag=${diag}` : ""} transform=${transform} spawns=${spawns} size=${sizeStr} walls=${wallCount}${czInfo}`;

            // Init timeline
            const frames = replayData.frames;
            maxTime = frames[frames.length - 1].t;
            currentTime = 0;
            
            document.getElementById('timeSlider').max = maxTime;
            document.getElementById('controls').style.display = 'block';

            // Init Mechs (from first frame that has them)
            const firstFrame = frames[0];
            for (const [id, state] of Object.entries(firstFrame.mechs)) {
                const mesh = createMechMesh(state.class, state.team);
                scene.add(mesh);
                mechMeshes[id] = mesh;

                // Paint Helper
                // Simple box helper for now, scaled to approx size
                const sz = MECH_SIZES[state.class];
                const geo = new THREE.BoxGeometry(sz[0], sz[1], sz[2]);
                const edges = new THREE.EdgesGeometry(geo);
                const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xff00ff }));
                line.visible = false;
                scene.add(line);
                paintHelpers[id] = line;

                // Status Bar Group
                const statGroup = new THREE.Group();
                // HP (Green)
                const hpBar = new THREE.Mesh(new THREE.PlaneGeometry(1, 0.15), new THREE.MeshBasicMaterial({color: 0x00ff00}));
                hpBar.position.set(0, 0.2, 0);
                statGroup.add(hpBar);
                // Stability (Blue)
                const stabBar = new THREE.Mesh(new THREE.PlaneGeometry(1, 0.15), new THREE.MeshBasicMaterial({color: 0x0088ff}));
                stabBar.position.set(0, 0, 0);
                statGroup.add(stabBar);
                // Heat (Red)
                const heatBar = new THREE.Mesh(new THREE.PlaneGeometry(1, 0.15), new THREE.MeshBasicMaterial({color: 0xff0000}));
                heatBar.position.set(0, -0.2, 0);
                statGroup.add(heatBar);

                statGroup.position.set(0, 0, MECH_SIZES[state.class][2] * 1.5);
                scene.add(statGroup);
                statusBars[id] = { group: statGroup, hp: hpBar, stab: stabBar, heat: heatBar };
            }

            updateScene(0);
        }

        function createMechMesh(cls, team) {
            const group = new THREE.Group();
            const color = TEAM_COLORS[team];
            const matBody = new THREE.MeshStandardMaterial({ color: color, roughness: 0.7 });
            const matDark = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.9 }); // Joints/Guns
            const matCockpit = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x004444, roughness: 0.2 });

            const sizes = MECH_SIZES[cls]; // [w, d, h]
            const w = sizes[0], d = sizes[1], h = sizes[2];

            if (cls === 'light' || cls === 'scout') {
                // LIGHT: Chicken Walker, Narrow
                // Legs
                const legGeo = new THREE.BoxGeometry(w*0.2, d*0.4, h*0.5);
                const legL = new THREE.Mesh(legGeo, matDark);
                legL.position.set(-w*0.25, 0, h*0.25);
                const legR = new THREE.Mesh(legGeo, matDark);
                legR.position.set(w*0.25, 0, h*0.25);
                group.add(legL); group.add(legR);

                // Torso
                const torsoGeo = new THREE.BoxGeometry(w*0.6, d*0.8, h*0.4);
                const torso = new THREE.Mesh(torsoGeo, matBody);
                torso.position.set(0, 0, h*0.7);
                group.add(torso);

                // Cockpit (Nose)
                const cockGeo = new THREE.BoxGeometry(w*0.3, d*0.3, h*0.2);
                const cockpit = new THREE.Mesh(cockGeo, matCockpit);
                cockpit.position.set(0, d*0.4, h*0.7);
                group.add(cockpit);

            } else if (cls === 'heavy') {
                // HEAVY: Wide, Shoulder Pods
                // Legs (Thick)
                const legGeo = new THREE.BoxGeometry(w*0.3, d*0.5, h*0.4);
                const legL = new THREE.Mesh(legGeo, matDark);
                legL.position.set(-w*0.3, 0, h*0.2);
                const legR = new THREE.Mesh(legGeo, matDark);
                legR.position.set(w*0.3, 0, h*0.2);
                group.add(legL); group.add(legR);

                // Pelvis
                const pelvisGeo = new THREE.BoxGeometry(w*0.5, d*0.4, h*0.1);
                const pelvis = new THREE.Mesh(pelvisGeo, matDark);
                pelvis.position.set(0, 0, h*0.45);
                group.add(pelvis);

                // Torso (Massive)
                const torsoGeo = new THREE.BoxGeometry(w*0.8, d*0.6, h*0.5);
                const torso = new THREE.Mesh(torsoGeo, matBody);
                torso.position.set(0, 0, h*0.75);
                group.add(torso);

                // Missile Pods (Shoulders)
                const podGeo = new THREE.BoxGeometry(w*0.25, d*0.5, h*0.25);
                const podL = new THREE.Mesh(podGeo, matBody);
                podL.position.set(-w*0.55, 0, h*0.85);
                const podR = new THREE.Mesh(podGeo, matBody);
                podR.position.set(w*0.55, 0, h*0.85);
                group.add(podL); group.add(podR);

                // Cockpit (Slit)
                const cockGeo = new THREE.BoxGeometry(w*0.4, d*0.1, h*0.1);
                const cockpit = new THREE.Mesh(cockGeo, matCockpit);
                cockpit.position.set(0, d*0.31, h*0.8);
                group.add(cockpit);

            } else {
                // MEDIUM: Standard Humanoid
                // Legs
                const legGeo = new THREE.BoxGeometry(w*0.25, d*0.3, h*0.45);
                const legL = new THREE.Mesh(legGeo, matDark);
                legL.position.set(-w*0.25, 0, h*0.225);
                const legR = new THREE.Mesh(legGeo, matDark);
                legR.position.set(w*0.25, 0, h*0.225);
                group.add(legL); group.add(legR);

                // Torso
                const torsoGeo = new THREE.BoxGeometry(w*0.7, d*0.5, h*0.5);
                const torso = new THREE.Mesh(torsoGeo, matBody);
                torso.position.set(0, 0, h*0.7);
                group.add(torso);

                // Arms (Guns)
                const armGeo = new THREE.BoxGeometry(w*0.15, d*0.6, h*0.2);
                const armL = new THREE.Mesh(armGeo, matBody);
                armL.position.set(-w*0.45, d*0.1, h*0.65);
                const armR = new THREE.Mesh(armGeo, matBody);
                armR.position.set(w*0.45, d*0.1, h*0.65);
                group.add(armL); group.add(armR);

                // Head
                const headGeo = new THREE.BoxGeometry(w*0.3, d*0.3, h*0.2);
                const head = new THREE.Mesh(headGeo, matBody);
                head.position.set(0, 0, h*1.05);
                group.add(head);
                
                // Visor
                const visorGeo = new THREE.BoxGeometry(w*0.25, d*0.1, h*0.1);
                const visor = new THREE.Mesh(visorGeo, matCockpit);
                visor.position.set(0, d*0.16, h*1.05);
                group.add(visor);
            }

            return group;
        }

                function togglePlay() {
                    isPlaying = !isPlaying;
                    document.getElementById('playPause').innerText = isPlaying ? "Pause" : "Play";
                }
        
                function toggleNav() {
                    if (!replayData || !replayData.world) return;
                    if (navGroup.children.length > 0 && navGroup.visible) {
                        navGroup.visible = false;
                        return;
                    }
                    if (navGroup.children.length > 0) {
                        navGroup.visible = true;
                        return;
                    }
        
                    // Fetch from server
                    fetch('/nav/build', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(replayData.world)
                    })
                    .then(r => r.json())
                    .then(data => {
                        renderNavGraph(data);
                        navGroup.visible = true;
                    })
                    .catch(err => console.error("Nav build failed:", err));
                }
        
                function renderNavGraph(data) {
                    navGroup.clear();
                    const nodes = data.nodes;
                    const nodeMat = new THREE.PointsMaterial({ color: 0x00ffff, size: 0.2 });
                    const points = [];
                    const posMap = {};
        
                    nodes.forEach(n => {
                        const p = new THREE.Vector3(...n.pos);
                        points.push(p);
                        posMap[n.id.join(',')] = p;
                    });
        
                    const pointsGeo = new THREE.BufferGeometry().setFromPoints(points);
                    const pointsMesh = new THREE.Points(pointsGeo, nodeMat);
                    navGroup.add(pointsMesh);
        
                    // Edges
                    const lineMat = new THREE.LineBasicMaterial({ color: 0x008888, transparent: true, opacity: 0.3 });
                    const linePoints = [];
                    nodes.forEach(n => {
                        const p1 = posMap[n.id.join(',')];
                        n.edges.forEach(eid => {
                            const p2 = posMap[eid.join(',')];
                            if (p2) {
                                linePoints.push(p1, p2);
                            }
                        });
                    });
                    const lineGeo = new THREE.BufferGeometry().setFromPoints(linePoints);
                    const lines = new THREE.LineSegments(lineGeo, lineMat);
                    navGroup.add(lines);
                }
        
                function togglePath() {
            if (!replayData || !replayData.world) return;
            if (pathGroup.visible) {
                pathGroup.visible = false;
                return;
            }
            if (selectedMechId) {
                requestPath(selectedMechId);
            } else {
                alert("Select a mech first (click on one)");
            }
        }

        function requestPath(mechId) {
            const frame = getFrameAt(currentTime);
            const mech = frame.mechs[mechId];
            if (!mech) return;

            const goalPos = frame.objective.zone_center.concat([0]); // [x,y,0]

            fetch('/nav/path', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    world: replayData.world,
                    start_pos: mech.pos,
                    goal_pos: goalPos
                })
            })
            .then(r => r.json())
            .then(data => {
                if (data.found) {
                    renderPath(data.path);
                    pathGroup.visible = true;
                } else {
                    console.warn("Path not found:", data.error);
                    pathGroup.clear();
                }
            })
            .catch(err => console.error("Path request failed:", err));
        }

        function renderPath(waypoints) {
            pathGroup.clear();
            const points = waypoints.map(p => new THREE.Vector3(...p));
            // Offset path slightly up so it's visible over the floor
            points.forEach(p => p.z += 0.5);

            const lineMat = new THREE.LineBasicMaterial({ color: 0xffff00, linewidth: 3 });
            const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(lineGeo, lineMat);
            pathGroup.add(line);

            // Waypoint markers
            const dotMat = new THREE.PointsMaterial({ color: 0xffff00, size: 0.3 });
            const dotGeo = new THREE.BufferGeometry().setFromPoints(points);
            const dots = new THREE.Points(dotGeo, dotMat);
            pathGroup.add(dots);
        }

        function getFrameAt(time) {
            const frames = replayData.frames;
            let frame = frames[0];
            for (let i = 0; i < frames.length - 1; i++) {
                if (time >= frames[i].t && time < frames[i+1].t) {
                    frame = frames[i];
                    break;
                }
            }
            if (time >= frames[frames.length - 1].t) frame = frames[frames.length - 1];
            return frame;
        }

        function updateScene(time) {	            if (!replayData) return;
            
            // Find frame
            // Simple linear search is fine for short replays
            const frames = replayData.frames;
            let frame = frames[0];
            for (let i = 0; i < frames.length - 1; i++) {
                if (time >= frames[i].t && time < frames[i+1].t) {
                    frame = frames[i];
                    break;
                }
            }
            if (time >= frames[frames.length - 1].t) frame = frames[frames.length - 1];

            document.getElementById('timeDisplay').innerText = time.toFixed(2) + "s / " + maxTime.toFixed(2) + "s";
            
	            const frameMechs = frame.mechs || {};
	            for (const id of Object.keys(mechMeshes)) {
	                if (!(id in frameMechs)) {
	                    mechMeshes[id].visible = false;
	                }
	            }
	            for (const id of Object.keys(statusBars)) {
	                if (!(id in frameMechs)) {
	                    statusBars[id].group.visible = false;
	                }
	            }

	            // Update Mechs
	            for (const [id, state] of Object.entries(frameMechs)) {
	                const mesh = mechMeshes[id];
	                if (mesh) {
	                    mesh.visible = state.alive;
	                    const hsZ = MECH_HALF_HEIGHTS[state.class] ?? 0.0;
	                    mesh.position.set(state.pos[0], state.pos[1], state.pos[2] - hsZ);
	                    
	                    if (state.fallen) {
	                        mesh.rotation.x = Math.PI / 2; // Lay flat
	                        mesh.rotation.z = state.yaw; // Keep yaw but sideways
                    } else {
                        mesh.rotation.x = 0;
                        mesh.rotation.z = state.yaw - Math.PI/2;
                    }
                    
                    // Show painted status
                    // (Handled by events/laser color)
                }

                // Update EWAR Bubbles
                if (state.class === 'scout' && (state.ecm_on || state.eccm_on)) {
                    let bubble = ewarMeshes[id];
                    if (!bubble) {
                        const geo = new THREE.SphereGeometry(3.6, 32, 32); // Visual scale for 18vox radius
                        const mat = new THREE.MeshBasicMaterial({
                            transparent: true,
                            opacity: 0.15,
                            side: THREE.BackSide // See inside from outside
                        });
                        bubble = new THREE.Mesh(geo, mat);
                        scene.add(bubble);
                        ewarMeshes[id] = bubble;
                    }
                    bubble.visible = state.alive;
                    bubble.position.set(state.pos[0], state.pos[1], state.pos[2]);
                    bubble.material.color.setHex(state.ecm_on ? 0xff00ff : 0x00ffff);
                    // Pulsing effect
                    const s = 1.0 + Math.sin(performance.now() * 0.005) * 0.05;
                    bubble.scale.set(s, s, s);
                } else if (ewarMeshes[id]) {
                    ewarMeshes[id].visible = false;
                }

                // Update Status Bars
                if (statusBars[id]) {
                    const sb = statusBars[id];
                    sb.group.visible = state.alive;
                    if (mesh) {
                        sb.group.position.copy(mesh.position);
                        sb.group.position.z += MECH_SIZES[state.class][2] * 0.8 + 1.0;
                    }
                    sb.group.lookAt(camera.position);

                    const fallbackMaxHp = {scout: 60, light: 80, medium: 120, heavy: 200}[state.class] || 100;
                    const maxHp = (typeof state.hp_max === 'number') ? state.hp_max : fallbackMaxHp;
                    const maxStab = (typeof state.stability_max === 'number') ? state.stability_max : 100.0;
                    const heatCap = (typeof state.heat_cap === 'number') ? state.heat_cap : 100.0;
                    sb.hp.scale.x = Math.max(0.01, Math.max(0, state.hp) / Math.max(1e-6, maxHp));
                    sb.stab.scale.x = Math.max(0.01, Math.max(0, (state.stability || 0)) / Math.max(1e-6, maxStab));
                    sb.heat.scale.x = Math.max(0.01, Math.min(2.0, Math.max(0, state.heat)) / Math.max(1e-6, heatCap));
                    
                    // Critical Heat Pulse
                    if (state.heat > heatCap * 0.85 && state.heat <= heatCap) {
                        const pulse = (Math.sin(performance.now() * 0.02) + 1) * 0.5; // 0..1
                        sb.heat.material.color.setHex(pulse > 0.5 ? 0xff0000 : 0xffff00);
                    } else {
                        sb.heat.material.color.setHex(0xff0000);
                    }
                }
                
                // Update Info Panel
                if (selectedMechId === id) {
                    document.getElementById('selId').innerText = id;
                    document.getElementById('selClass').innerText = state.class;
                    document.getElementById('selHp').innerText = Math.round(state.hp);
                    document.getElementById('selMaxHp').innerText = Math.round((typeof state.hp_max === 'number') ? state.hp_max : ({scout: 60, light: 80, medium: 120, heavy: 200}[state.class] || 100));
                    document.getElementById('selHeat').innerText = Math.round(state.heat);
                    document.getElementById('selHeatCap').innerText = Math.round((typeof state.heat_cap === 'number') ? state.heat_cap : 100);
                    document.getElementById('selStab').innerText = Math.round(state.stability || 0);
                    document.getElementById('selStabMax').innerText = Math.round((typeof state.stability_max === 'number') ? state.stability_max : 100);
                    document.getElementById('selLegged').innerText = state.legged ? "yes" : "no";
                    document.getElementById('selSuppressed').innerText = (typeof state.suppressed_time === 'number') ? (state.suppressed_time.toFixed(1) + "s") : "-";
                    document.getElementById('selEwar').innerText = state.ecm_on ? "ECM" : (state.eccm_on ? "ECCM" : "off");
                    document.getElementById('selAms').innerText = (typeof state.ams_cooldown === 'number') ? (state.ams_cooldown.toFixed(1) + "s") : "-";
                    let status = "Active";
                    if (!state.alive) status = "Destroyed";
                    else if (state.fallen) status = "FALLEN (Stun)";
                    else {
                        const cap = (typeof state.heat_cap === 'number') ? state.heat_cap : 100.0;
                        if (state.heat > cap) status = "Shutdown";
                    }
                    document.getElementById('selState').innerText = status;
                    
                    // Highlight?
                    if (mechMeshes[id]) {
                        // Maybe add a bracket helper? For now UI is enough.
                    }
                }
            }

            // Update Smoke Clouds
            const frameSmoke = frame.smoke_clouds || [];
            if (!window.smokeMeshes) window.smokeMeshes = [];
            // Reuse meshes? For now just clear and rebuild or hide
            window.smokeMeshes.forEach(m => { m.visible = false; });
            frameSmoke.forEach((c, i) => {
                let mesh = window.smokeMeshes[i];
                if (!mesh) {
                    const geo = new THREE.SphereGeometry(1, 16, 16);
                    const mat = new THREE.MeshBasicMaterial({ color: 0x888888, transparent: true, opacity: 0.4 });
                    mesh = new THREE.Mesh(geo, mat);
                    scene.add(mesh);
                    window.smokeMeshes[i] = mesh;
                }
                mesh.visible = true;
                mesh.position.set(c.pos[0], c.pos[1], c.pos[2]);
                mesh.scale.set(c.radius, c.radius, c.radius);
            });

            // Events (Lasers/Missiles)
            const recentEvents = frame.events || [];
            
            // Clear old ephemeral FX
            laserLines.forEach(l => scene.remove(l));
            laserLines = [];
            
	            // Rebuild
	            recentEvents.forEach(ev => {
                    const weapon = ev.weapon || null;
	                const shooter = frameMechs[ev.shooter];
	                const target = frameMechs[ev.target];
	                const pos = ev.pos ? new THREE.Vector3(...ev.pos) : (target ? new THREE.Vector3(...target.pos) : null);
	                const origin = shooter ? new THREE.Vector3(...shooter.pos) : null;

                if (ev.damage > 0 && target) {
                    spawnFloater(new THREE.Vector3(...target.pos), "-" + Math.round(ev.damage), 0xff0000);
                }
                
                if (ev.type === 'paint') {
                    if (origin && target) drawBeam(origin, new THREE.Vector3(...target.pos), 0xff00ff, 1);
                }
                else if (ev.type === 'laser_hit') {
                    if (origin && target) {
                        let color = 0x00ff00; // Green
                        if (weapon === 'flamer') color = 0xff6600; // Orange for flamer
                        else if (ev.is_painted) color = 0x00ffff; // Cyan
                        if (ev.is_crit) color = 0xff0000; // Red (Override)
                        drawBeam(origin, new THREE.Vector3(...target.pos), color, 2);
                    }
                }
                else if (ev.type === 'smoke_cloud') {
                    if (pos) drawExplosion(pos, ev.radius, 0xcccccc);
                }
                else if (ev.type === 'smoke_launch') {
                    if (origin) drawFlash(origin, 0xcccccc, 1);
                }
                else if (ev.type === 'projectile_hit') {
                    // Tracers for impacts
                    if (origin && target) {
                        // Use weapon when available; fallback to stability heuristic.
                        let color = 0xffaa00;
                        let width = 1;
                        let size = 1;
                        if (weapon === 'gauss') {
                            color = 0xffff00;
                            width = 3;
                            size = 2;
                        } else if (weapon === 'autocannon') {
                            color = 0xffaa00;
                            width = 1;
                            size = 1;
                        } else if (weapon === 'missile') {
                            color = 0xff4500;
                            width = 2;
                            size = 2;
                        } else {
                            const isHeavy = ev.stability > 10;
                            color = isHeavy ? 0xffff00 : 0xffaa00;
                            width = isHeavy ? 3 : 1;
                            size = isHeavy ? 2 : 1;
                        }
                        if (weapon !== 'missile') {
                            drawTracer(origin, new THREE.Vector3(...target.pos), color, width);
                        }
                        drawFlash(new THREE.Vector3(...target.pos), color, size);
                    }
                }
                else if (ev.type === 'missile_hit') {
                    // Usually handled by explosion logic now, but legacy check
                    if (pos) drawExplosion(pos, 2.5, 0xff4500);
                }
                else if (ev.type === 'explosion') {
                    if (pos) drawExplosion(pos, ev.radius, 0xff4500);
                }
                else if (ev.type === 'ams_intercept') {
                    const defender = frameMechs[ev.defender];
                    if (defender && pos) {
                        const dpos = new THREE.Vector3(...defender.pos);
                        drawBeam(dpos, pos, 0x66ccff, 2);
                        drawFlash(pos, 0x66ccff, 1);
                    } else if (pos) {
                        drawFlash(pos, 0x66ccff, 1);
                    }
                }
                else if (ev.type === 'missile_launch') {
                    // Draw launch puff
                    if (origin) drawFlash(origin, 0xffffff, 1);
                }
                else if (ev.type === 'kinetic_fire') {
                    if (origin) {
                        const c = (weapon === 'gauss') ? 0xffff00 : 0xffaa00;
                        drawFlash(origin, c, 1);
                    }
                }
            });
        }

        // --- FX Helpers ---
        function drawBeam(p1, p2, color, width) {
            const mat = new THREE.LineBasicMaterial({ color: color, linewidth: width });
            const geo = new THREE.BufferGeometry().setFromPoints([p1, p2]);
            const line = new THREE.Line(geo, mat);
            scene.add(line);
            laserLines.push(line);
        }

        function drawTracer(p1, p2, color, width) {
            // Dashed line look for kinetics? Or just a thick short line?
            // ThreeJS lines are solid.
            // Let's draw a shorter line segment at the end (impact) to simulate a tracer arriving.
            const dir = new THREE.Vector3().subVectors(p2, p1).normalize();
            const start = new THREE.Vector3().subVectors(p2, dir.multiplyScalar(10)); // 10m tail
            // Clamp start to p1 if too close
            if (start.distanceTo(p2) > p1.distanceTo(p2)) start.copy(p1);
            
            drawBeam(start, p2, color, width);
        }

        function drawFlash(pos, color, size) {
            const geo = new THREE.SphereGeometry(size * 0.5, 8, 8);
            const mat = new THREE.MeshBasicMaterial({ color: color });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(pos);
            scene.add(mesh);
            laserLines.push(mesh);
        }

        function drawExplosion(pos, radius, color) {
            const geo = new THREE.SphereGeometry(radius, 16, 16);
            const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.6 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(pos);
            scene.add(mesh);
            laserLines.push(mesh);
        }

        function spawnFloater(pos, text, colorHex) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 128; 
            canvas.height = 64;
            ctx.font = "bold 48px sans-serif";
            ctx.fillStyle = "#" + colorHex.toString(16).padStart(6, '0');
            ctx.textAlign = "center";
            ctx.fillText(text, 64, 48);
            
            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
            const sprite = new THREE.Sprite(mat);
            sprite.position.copy(pos);
            sprite.position.z += 2; // Above head
            sprite.scale.set(4, 2, 1); // Size in world units
            
            scene.add(sprite);
            floaters.push({ mesh: sprite, life: 1.0 });
        }

        function animate() {
            requestAnimationFrame(animate);

            // Update Floaters
            for (let i = floaters.length - 1; i >= 0; i--) {
                const f = floaters[i];
                f.life -= 0.02; // Fade speed
                f.mesh.position.z += 0.05; // Float up
                f.mesh.material.opacity = f.life;
                if (f.life <= 0) {
                    scene.remove(f.mesh);
                    floaters.splice(i, 1);
                }
            }

            if (isPlaying && replayData) {
                const now = performance.now();
                const delta = (now - lastFrameTime) / 1000;
                lastFrameTime = now;
                
                // Clamping delta to avoid jumps
                if (delta < 0.2) {
                    currentTime += delta * playbackSpeed;
                    if (currentTime > maxTime) {
                        currentTime = 0; // Loop or stop
                        // isPlaying = false; 
                    }
                    document.getElementById('timeSlider').value = currentTime;
                    updateScene(currentTime);
                }
            } else {
                lastFrameTime = performance.now();
            }

            controls.update();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
